

选择哪款消息队列更适合你的业务系统？如何保证系统的高可靠、高可用和高性能？如何保证消息不重复、不丢失？如何做到水平扩展？

Kafka，RocketMQ，RabbitMQ



### 应用场景

#### 异步处理

对于一个用户请求来说，可能会有风险控制，库存锁定，生成订单，短信通知，信息统计等，但是对于一个秒杀系统来说（在有限的电脑资源下，单位时间内响应尽可能多的响应用户的海量请求），当执行到库存锁定的时候就可以将请求成功的消息发送给用户了，而后续的操作可以放在消息队列中在后续进行操作，能够在较短时间内响应更多的请求

#### 流量控制

- 在网关和后端服务之间添加消息队列，这种结构的坏处是：1、增加了调用链的长度，增加了系统的响应时延；2、需要将后端服务从同步处理改为异步处理，增加了系统的复杂性。

- 使用令牌桶，单位时间内生成固定数量的令牌放置在令牌桶中，每次网关处理用户的请求都要在令牌桶中获取令牌，当令牌为空的时候拒绝请求的访问。实现起来简单，不需要修改后端服务的处理逻辑

#### 系统解耦

对于订单系统来说，下游的服务随时都会增加与变更，为了防止每次变更都要修改订单系统并且重新上线，可以使用消息队列作为各个子系统之间的桥梁，减少子系统之间的耦合性

#### 将消息发送给订阅者

#### 连接流处理任务和数据

#### 作为发布/订阅系统实现一个微服务级系统间的观察者模式



### 消息队列的缺点

- 增加了系统的复杂性
- 增加了整体系统的响应时延
- 可能产生数据不一致的问题



### JMS和AMQP

JMS（JAVA Message Service,java消息服务）是java的消息服务。JMS API是一个消息服务的标准或者说是规范，允许应用程序组件**基于JavaEE平台**创建、发送、接收和读取消息。ActiveMQ 就是基于 JMS 规范实现的。

AMQP（Advanced Message Queuing Protocol），一个提供统一消息服务的应用层标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。跨语言，跨平台。RabbitMQ 就是基于 AMQP 协议实现的。



### 消息队列的产品

选择产品的一些标准：

开源（可以二次开发或者有问题的时候可以看源码）、活跃的社区（少Bug），和周边的产品有较好的兼容性，支持集群，数据一致性，性能

#### RabbitMQ

优点：开箱即用，轻量级，支持较多数语言；使用的是Erlang语言，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级；

缺点：对数据堆积不友好，当大量数据堆积的时候会导致性能急速下降；1秒处理几万到十几万

使用场景：开箱机用，易于维护，功能简单

#### RocketMQ

优点：稳定性好，可靠性好，每秒钟处理几十万条消息，使用java开发，活跃的社区，对在线业务的响应时延做了很多优化，可以达到毫秒级的响应

缺点：国产，因此和周边产品的兼容性较差

使用场景：在线金融级稳定低时延性业务

#### Kafka

优点：1秒能够处理几百万或上千万的数据，适合大数据处理；和周边产品兼容性最好；设计上使用了异步和批量思想

缺点：有数据缺失；有可能消息重复消费

使用场景：离线大数据处理业务



### 消息模型

- 队列模型：RabbitMQ
- 发布/订阅模型：Kafka，RocketMQ

两者最大的区别主要是，一份消息是否能够被多次消费

而RabbitMQ解决消息消费多次的问题，在生产者和队列中间添加了Exchange模块，用来路由消息，每个消费者会对应一个队列，Exchange模块将消息发送给需要的所有消费者对应的队列

使用请求-确认机制来保证了消息传递过程的可靠性，这种机制导致了每次只能有一个消费者处理消息，这样没有办法水平扩展消费者的数量来提高消费端的能力

而RocketMQ，每个Topic下都有多个队列，通过多个队列来实现多实例并行生产和消费，即提高并发能力；消费组有多个消费者，每个消费者负责消费组内的一部分消息

Kafka的模型和RocketMQ的一样，只不过Kafka中用分区（Partition）取代队列这个说法



### 事务

为了解决生产者和消费者的数据一致性问题，需要实现事务，而对于分布式场景，则是分布式事务

分布式事务的实现有：2PC，TCC（Try-Confirm-Cancel）和事务消息

#### 事务消息

事务消息适用于需要异步更新的数据，并且对数据的实时性要求不高

例子：订单系统创建订单，将订单发送给消息队列，购物车系统消费订单，清除购物车的内容。

这当中订单创建和购物车清除两者需要满足事务

使用消息队列实现分布式事务：

1. 订单系统在消息队列开启一个事务；
2. 订单系统发送半消息（或者称为事务消息）给队列（半消息：是一个完整的消息，在消息提交之前，消费者看不到）
3. 订单系统执行本地事务，创建订单；
4. 订单系统根据本地事务的执行结果，提交或者撤回消息，提交后的消息，消费者可以进行消费

对于事务消息，RocketMQ是将其放在一个特殊的主题A中，如果接收到提交事务的信息，则将其从主题A挪到正确的Topic下；而Kafka是将消息放到正确的主题分区中，在客户端消费的时候过滤掉

如果过程中的第四步失败，Kafka的做法是抛出异常，让用户进行处理，一般是循环重试；而RocketMQ则是使用了反查机制，当消息队列的的Broker没有收到提交或者撤回消息，那么其会定时向订单系统查询该事务的本地事务的执行情况，根据执行情况来决定消息的处理，从而能够解决事务提交消息可能出现的通信故障问题，具体的是对主题A设置了一个定时器，定时从主题A中读取待反查的事务消息，向Producer发送RPC请求。

RocketMQ的事务解决的问题是确保本地事务和发消息两个操作，要么都成功，要么都失败，并且使用了反查机制，来提高事务的执行成功率

Kafka的事务解决的问题是确保在一个事务中发送的多条消息，要么都成功，要么都失败，用来实现Exactly Once机制。主要适用的场景是将Kafka作为数据源，经过计算后，结果存放在Kafka中，这儿每条消息都只被计算一次

### 保证消息的不丢失

#### 如何发现消息是否丢失

- 分布式链路追踪系统，可以很方便地追踪每一条消息
- 在Producer端生成连续的序列，在Consumer端检测序列是否连续

#### 确保消息的可靠性

消息的传递可以分为三个过程，Producer生成消息发送给Broker，Broker保存消息，Consumer消费消息，在这三个过程正确处理消息来保证消息的可靠性

- Producer生成消息发送给Broker：由于使用了确认机制，即Broker收到消息后发给Producer确认消息，Producer如果收到确认消息表示消息已经成功保存在Broker。如果Producer如果没有收到确认消息就重新发送，多次失败后会抛出异常或者返回值，编写代码的时候需要正确处理返回值和捕获异常。
- Broker保存消息：保证消息存盘后才发送确认消息给Producer；对于分布式系统，将消息复制到其他节点
- Consumer消费消息：消费确认机制，每次处理完消息后发送确认消息给Broker



---

### 处理消费过程中的重复消息

- 将业务逻辑操作设计成幂等操作。比如给A账户增加100元，这个操作是不幂等的，可以将操作设计为给A账户的金额设置为300元，这个操作是幂等的
- 数据库的唯一约束。比如给A账户增加100元，那么可以在DB中创建一个表，账户ID和账单ID为唯一索引，那么当有多个重复消息到达消费端的时候，表里由于唯一约束，只会有一行记录。当然了这儿也可以不用DB，可以用Redis的SETNX，只要具备“Insert If not Exist”的存储系统都可以
- 数据更新前设置条件。比如给A账户增加100元，可以设计成为当A账户当前金额为500元的时候，才增加100元，具备幂等性。更通用的做法是给数据添加版本号属性，当消息的数据版本号和数据的版本号不一致的时候不执行，一致才执行并且将版本号+1。
- 记录消息并检查是否执行过。这是比较通用的做法，对于每一条消息检查是否执行过，如果没有执行过则执行，并且设置为执行过。这种方法执行难度比较高，在分布式系统中很难实现，因为检查、更新、记录这三个操作需要原子性，当然可以用事务或者分布式锁来实现，但是比较难



### 消息积压

#### 提高性能防止消息积压

消息队列的性能一般来说是比业务系统的性能要好，消息队列单节点的数据处理能力每秒能够处理几万到几十万的消息，而且能够水平扩展Broker来成倍提升处理能力，所以一般需要考虑的是提高Producer的生产能力和Consumer的消费能力

Producer可以通过并发和批量来提高性能，并发适合于在线系统，批量由于不能快速响应请求适合于离线系统

Consumer可以通过增加Consumer来提高消费能力，同时也要保持Topic下Partition数量和Consumer数量的一致，一般我们需要保证消费能力大于生产能力，保证系统的健康

#### 消息积压了怎么办

积压的原因：Consumer消费能力变弱或者Producer生产能力变强

- 首先检查消费节点是否宕机
- 水平扩展消费端的实例提高消费能力，如果服务器资源有限，需要降级系统服务，保证关键业务的正常运行（比如电商进行促销导致Producer产能变高）
- 消息消费是否失败，是否多次消费，通过日志查看消费失败的原因

- 查看消费线程的堆栈，是否因为死锁或者请求资源而停滞



### 学习开源代码

最佳的方法就是看官方英文的文档

1. 先看使用场景、特性（Feature）、生态圈（Ecosystem）、介绍（Introduction，关注特有的名词）
2. Quick Start
3. 阅读原理，推荐看论文
4. 开源代码太大了，而且是网状的结构，容易迷失自我。建议带着问题和答案去阅读原文，一次只看一个点
5. 如果没有问题还是看文档，看核心功能的实现原理（Design，Implementation，Improvement Proposal）


