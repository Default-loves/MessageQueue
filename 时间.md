做算法题

- 获取思路
  - 多题一解
  - 一题多解
- 具体实现
- 作总结
- 



## 消息队列

选择哪款消息队列更适合你的业务系统？如何保证系统的高可靠、高可用和高性能？如何保证消息不重复、不丢失？如何做到水平扩展？

Kafka，RocketMQ



### 应用场景

#### 异步处理

对于一个用户请求来说，可能会有风险控制，库存锁定，生成订单，短信通知，信息统计等，但是对于一个秒杀系统来说（在有限的电脑资源下，单位时间内响应尽可能多的响应用户的海量请求），当执行到库存锁定的时候就可以将请求成功的消息发送给用户了，而后续的操作可以放在消息队列中在后续进行操作，能够在较短时间内响应更多的请求

#### 流量控制

- 在网关和后端服务之间添加消息队列，这种结构的坏处是：1、增加了调用链的长度，增加了系统的响应时延；2、需要将后端服务从同步处理改为异步处理，增加了系统的复杂性。

- 使用令牌桶，单位时间内生成固定数量的令牌放置在令牌桶中，每次网关处理用户的请求都要在令牌桶中获取令牌，当令牌为空的时候拒绝请求的访问。实现起来简单，不需要修改后端服务的处理逻辑

#### 系统解耦

对于订单系统来说，下游的服务随时都会增加与变更，为了防止每次变更都要修改订单系统并且重新上线，可以使用消息队列作为各个子系统之间的桥梁，减少子系统之间的耦合性

#### 将消息发送给订阅者

#### 连接流处理任务和数据

#### 作为发布/订阅系统实现一个微服务级系统间的观察者模式



### 消息队列的缺点

- 增加了系统的复杂性
- 增加了整体系统的响应时延
- 可能产生数据不一致的问题



### 消息队列的产品

一些标准：开源（可以二次开发或者有问题的时候可以看源码）、活跃的社区（少Bug），和周边的产品有较好的兼容性，支持集群，数据一致性，性能

#### RabbitMQ

优点：开箱机用，轻量级，支持叫多数语言

缺点：使用的是Erlang语言；对数据堆积不友好，当大量数据堆积的时候会导致性能急速下降；1秒处理几万到几十万

使用场景：开箱机用，易于维护，功能简单

#### RocketMQ

优点：稳定性好，可靠性好，每秒钟处理几十万条消息，使用java开发，活跃的社区，对在线业务的响应时延做了很多优化，可以达到毫秒级的响应

缺点：国产，因此和周边产品的兼容性较差

使用场景：在线金融级稳定低时延性业务

#### Kafka

优点：1秒能够处理几百万或上千万的数据，适合大数据处理；和周边产品兼容性最好；设计上使用了异步和批量思想

缺点：有数据缺失；

使用场景：离线大数据处理业务



### 消息模型

- 队列模型：RabbitMQ
- 发布/订阅模型：Kafka，RocketMQ

两者最大的区别主要是，一份消息是否能够被多次消费

而RabbitMQ解决消息消费多次的问题，在生产者和队列中间添加了Exchange模块，用来路由消息，每个消费者会对应一个队列，Exchange模块将消息发送给需要的所有消费者对应的队列

使用请求-确认机制来保证了消息传递过程的可靠性，这种机制导致了每次只能有一个消费者处理消息，这样没有办法水平扩展消费者的数量来提高消费端的能力

而RocketMQ，每个Topic下都有多个队列，通过多个队列来实现多实例并行生产和消费；消费组有多个消费者，每个消费者负责消费组内的一部分消息

Kafka的模型和RocketMQ的一样，只不过Kafka中用分区（Partition）取代队列这个说法



### 事务

为了解决生产者和消费者的数据一致性问题，需要实现事务，而对于分布式场景，则是分布式事务

分布式事务的实现有：2PC，TCC（Try-Confirm-Cancel）和事务消息

事务消息适用于需要异步更新的数据，并且对数据的实时性要求不高

例子：订单系统创建订单，将订单发送给消息队列，购物车系统消费订单，清除购物车的内容。

这当中订单创建和购物车清除两者需要满足事务

使用消息队列实现分布式事务：

1. 订单系统在消息队列开启一个事务；
2. 订单系统发送半消息给队列（半消息：是一个完整的消息，在消息提交之前，消费者看不到）
3. 订单系统执行本地事务，创建订单；
4. 订单系统根据本地事务的执行结果，提交或者撤回消息

当中的第四步失败的话，Kafka的做法是抛出异常，让用户进行处理，一般是循环重试，而RocketMQ则是使用了反查机制，当消息队列的的Broker没有收到提交或者撤回消息，那么其会定时向订单系统查询该事务的本地事务的执行情况，根据执行情况来决定消息的处理，从而能够解决事务提交消息可能出现的通信故障问题